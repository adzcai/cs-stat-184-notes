---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.16.2
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Introduction

Welcome to the study of reinforcement learning! This textbook accompanies the undergraduate course [CS/STAT 184](https://shamulent.github.io/CS_Stat184_Fall23.html) taught at Harvard and is intended to be a friendly yet rigorous introduction to this active subfield of machine learning. Here are some questions you might have before embarking on this journey:

+++

## Prerequisites

This book assumes familiarity with multivariable calculus, linear algebra, and probability. For Harvard undergraduates, this would be fulfilled by Math 21a, Math 21b, and Stat 110. Stat 111 is strongly recommended but not required. Here is a non-comprehensive list of topics you should be familiar with before starting this book:

-   **Linear Algebra:** Vectors and matrices, matrix multiplication, matrix
    inversion, eigenvalues and eigenvectors, and the Gram-Schmidt
    process.
-   **Multivariable Calculus:** Partial derivatives, gradients,
    directional derivatives, the chain rule, Taylor series.
-   **Probability:** Random variables, probability distributions,
    expectation and variance, the law of iterated expectations (Adam's rule), covariance, conditional probability, Bayes's rule, and the law of total probability.

+++

## Reinforcement learning in a nutshell

Broadly speaking, RL is a subfield of machine learning that studies how an agent can learn to make sequential decisions in a dynamic environment. It provides a powerful framework for attacking a wide variety of problems, including robotic control, video games and board games, resource management, language modelling, and more. It also provides an interdisciplinary paradigm for studying animal and human behavior. Many of the most stunning results in machine learning, ranging from AlphaGo to ChatGPT, are built on top of RL.

**How does reinforcement learning differ from other machine learning paradigms?** Machine learning is often broken down into the three subcategories of supervised learning, unsupervised learning, and reinforcement learning.

-   **Supervised learning.** Supervised learning concerns itself with
    learning a mapping from inputs to outputs (e.g. image
    classification). Typically the data takes the form of input-output
    pairs that are assumed to be sampled independently from some
    generating distribution. In RL, however, the data is generated by
    the agent interacting with the environment, meaning the observations
    depend on the agent's behaviour and are not independent from each
    other. This requires a more general set of tools.

    Conversely, supervised learning is a well-studied field that
    provides many useful tools for RL. For example, it may be useful to
    use supervised learning to predict how valuable a given state is, or
    to predict the probability of transitioning to a given state.

-  **Unsupervised learning.** Unsupervised learning deals with learning the
    structure of data without the use of labels.

### Challenges of reinforcement learning

The RL task is quite general. It will be helpful to decompose it into a few subtasks that can be tackled separately. This decomposition also provides a useful framework for analyzing the algorithms we will encounter.

**Policy evaluation (prediction):** How 'good' is a specific state, or state-action pair? That is, how much reward does it lead to in the long run?

**Policy optimization (control):** Suppose we have a complete, accurate model of how the environment behaves. What is the best action to take in every scenario?

**Recursion (bootstrapping):** How can we "reuse" our current predictions to generate new information?

**Exploration-exploitation tradeoff:** Should we try new actions, or capitalize on actions that we currently believe to be good?

+++

## Overview

{ref}`bandits` discusses **multi-armed bandits,** a simple model for
reinforcement learning. In this setting, there are multiple arms, each with their own reward distribution. The agent must decide which arm to pull at each time step.

{ref}`mdps` introduces (finite) **Markov Decision Processes**, a mathematical framework for describing interactive environments. Certain states and actions will be rewarded, and the agent's goal is to maximize its total reward.

{ref}`fitted_dp` introduces **fitted dynamic programming** algorithms for solving MDPs when the state space is too large to be enumerated. These algorithms borrow ideas from supervised learning to approximate the value function (discussed in {ref}`mdps`).

{ref}`lqr` is a standalone chapter on the **linear quadratic regulator**,
an important tool for *continuous control*, in which the state space is no longer finite (i.e. $|\mathcal{S}| < \infty$) but rather continuous (i.e. $|\mathcal{S}| = \mathbb{R}^{n_s}$).

+++

| Chapter | States | Actions | Rewards (or costs) |
|:-------:|:------:|:-------:|:-------:|
| {ref}`bandits` | N/A | Finite | Stochastic |
| {ref}`mdps` | Finite | Finite | Deterministic |
| {ref}`fitted_dp` | Large or continuous | Finite | Deterministic |
| {ref}`lqr` | Continuous | Continuous | Deterministic |

+++

## Notation

We will use the following notation throughout the book. This notation is
inspired by {cite}`sutton_reinforcement_2018` and {cite}`agarwal_reinforcement_2022`.

| Notation      | Definition                |
|:-------------:|:--------------------------|
|      $s$      | A state.                  |
|      $a$      | An action.                |
|      $r$      | A reward.                 |
|      $p$      | A probability.            |
|     $\pi$     | A policy.                 |
|      $V$      | A value function.         |
|      $Q$      | An action-value function. |
|      $A$      | An advantage function.    |
|   $\gamma$    | A discount factor.        |
|    $\tau$     | A trajectory.             |
| $\mathcal{S}$ | A state space.            |
| $\mathcal{A}$ | An action space.          |

+++

## Programming

Why include code in a textbook? We believe that implementing an algorithm is a strong test of your understanding of it; mathematical notation can often abstract away details, while a computer must be given every detailed instruction. We have sought to write concise, readable, idiomatic Python code that is self-contained within each file. This approach is inspired by {cite}`sussman_functional_2013`.

This is an interactive book built with [Jupyter Book](https://jupyterbook.org/en/stable/intro.html). It uses [Python 3.11](https://docs.python.org/3.11/contents.html). It uses the [JAX](https://jax.readthedocs.io/en/latest/index.html) library for numerical computing. JAX was chosen for the clarity of its functional style and due to its mature RL ecosystem, sustained in large part by the Google DeepMind research group and a large body of open-source contributors. We use the standard [Gymnasium](https://gymnasium.farama.org/) library for interfacing with RL environments.

+++

## O notation

Throughout this chapter and the rest of the book, we will describe the
asymptotic behavior of a function using $O$ notation.

For two functions $f(t)$ and $g(t)$, we say that $f(t) \le O(g(t))$ if
$f$ is asymptotically upper bounded by $g$. Formally, this means that
there exists some constant $C > 0$ such that $f(t) \le C \cdot g(t)$ for
all $t$ past some point $t_0$.

We say $f(t) < o(g(t))$ if asymptotically $f$ grows strictly slower than
$g$. Formally, this means that for *any* scalar $C > 0$, there exists
some $t_0$ such that $f(t) \le C \cdot g(t)$ for all $t > t_0$.
Equivalently, we say $f(t) < o(g(t))$ if
$\lim_{t \to \infty} f(t)/g(t) = 0$.

$f(t) = \Theta(g(t))$ means that $f$ and $g$ grow at the same rate
asymptotically. That is, $f(t) \le O(g(t))$ and $g(t) \le O(f(t))$.

Finally, we use $f(t) \ge \Omega(g(t))$ to mean that $g(t) \le O(f(t))$,
and $f(t) > \omega(g(t))$ to mean that $g(t) < o(f(t))$.

We also use the notation $\tilde O(g(t))$ to hide logarithmic factors.
That is, $f(t) = \tilde O(g(t))$ if there exists some constant $C$ such
that $f(t) \le C \cdot g(t) \cdot \log^k(t)$ for some $k$ and all $t$.

Occasionally, we will also use $O(f(t))$ (or one of the other symbols)
as shorthand to manipulate function classes. For example, we might write
$O(f(t)) + O(g(t)) = O(f(t) + g(t))$ to mean that the sum of two
functions in $O(f(t))$ and $O(g(t))$ is in $O(f(t) + g(t))$.
