# Introduction

Welcome to the study of reinforcement learning!
This textbook accompanies the undergraduate course [CS 1840/STAT 184](http://lucasjanson.fas.harvard.edu/CS_Stat_184_0.html) taught at Harvard.
It is intended to be a friendly yet rigorous introduction to this active subfield of machine learning.

+++

## Prerequisites

This book assumes the same prerequisites as the course: You should be familiar with multivariable calculus, linear algebra, and probability.
For Harvard undergraduates, this is fulfilled by Math 21a, Math 21b, and Stat 110, or their equivalents.
Stat 111 is strongly recommended but not required.
Specifically, we will assume that you know the following topics. The _italicized terms_ have brief re-introductions in the text or in the {ref}`background`:

-   **Linear Algebra:** Vectors and matrices, matrix multiplication, matrix
    inversion, eigenvalues and eigenvectors.
-   **Multivariable Calculus:** Partial derivatives, the chain rule, Taylor series, _gradients, directional derivatives, Lagrange multipliers._
-   **Probability:** Random variables, probability distributions,
    expectation and variance, the law of iterated expectations (Adam's rule), covariance, conditional probability, Bayes's rule, and the law of total probability.

You should also be comfortable with programming in Python.
See {ref}`programming` for more about this textbook's philosophy regarding programming.

+++

## Reinforcement learning in a nutshell

Broadly speaking,
RL studies **sequential decision-making** in **dynamic environments.**
An RL algorithm finds a **policy,** or strategy, that maximizes the **reward** it obtains from the environment.

RL provides a powerful framework for attacking a wide variety of problems,
including robotic control, video games and board games, resource management, language modelling, and more.
It also provides an interdisciplinary paradigm for studying animal and human behavior.
Many of the most stunning results in machine learning, ranging from AlphaGo to ChatGPT, are built on top of RL.

How does RL compare to **supervised learning** and **unsupervised learning,**
the other two core machine learning paradigms?

- **Supervised learning** (SL) concerns itself with learning a mapping from inputs to outputs.
  Typically the data takes the form of _statistically independent_ input-output pairs.
  In RL, however, the data is generated by the agent interacting with the environment,
  meaning the sequential observations of the state are **not independent** from each other.

  Conversely, SL is a well-studied field that provides many useful tools for RL.
  For example, it may be useful to use supervised learning to predict how valuable a given state is, or to predict the probability of transitioning to a given state.
  We will see concrete examples in {ref}`fitted_dp`.

- **Unsupervised learning** concerns itself with learning the _structure_ of data without the use of "labels".
  In RL, though, the agent receives a **reward signal** from the environment,
  which can be thought of as a type of "label".

  Unsupervised learning (especially **self-supervised** learning) is crucial in many applications of RL for purposes such as dimensionality reduction or representation learning.

+++

## Core tasks in reinforcement learning

What tasks, exactly, does RL comprise?
RL algorithms typically must solve two main subtasks:

- **Policy evaluation (prediction):**
  How 'good' is a specific state, or state-action pair (for a specific agent)?
  That is, how much reward does it lead to in the long run?

- **Policy optimization (control):**
  Suppose we have a complete, accurate model of how the environment behaves.
  What is the best action to take in every scenario?

This decomposition also provides a useful framework for analyzing the algorithms we will encounter.

<!-- **Recursion (bootstrapping):** How can we "reuse" our current predictions to generate new information? -->

<!-- **Exploration-exploitation tradeoff:** Should we try new actions, or capitalize on actions that we currently believe to be good? -->

+++

## Overview

The course will progress through the following units:

{ref}`mdps` introduces (finite) **Markov Decision Processes,**
the core mathematical framework for describing interactive environments,
as well as the core vocabulary we will use throughout the course.

{ref}`lqr` is a standalone chapter on the **linear quadratic regulator**,
an important tool for *continuous control*,
in which the state and action spaces are no longer finite but rather continuous.
This has widespread applications in robotics.

{ref}`bandits` introduces the **multi-armed bandit** model for **stateless** sequential decision-making tasks.
In exploring a number of algorithms,
we will see how each of them strikes a different balance between _exploring_ new options and _exploiting_ known options.
This **exploration-exploitation tradeoff** is a core consideration in RL algorithm design.

{ref}`supervised_learning` is a standalone crash course on some tools from supervised learning that we will use in later chapters.

{ref}`fitted_dp` introduces **fitted dynamic programming** algorithms for solving MDPs.
These algorithms use supervised learning to approximately evaluate policies when they cannot be evaluated exactly.

{ref}`pg` walks through an important class of algorithms based on iteratively improving the policy.

{ref}`imitation_learning` attempts to learn a good policy from expert demonstrations.
At its most basic, this is an application of supervised learning to RL tasks.

{ref}`planning` looks at ways to _explicitly_ plan ahead when the dynamics of the environment are known.
We will study the _Monte Carlo Tree Search_ heuristic,
which has been used to great success in the famous AlphaGo algorithm and its successors.

{ref}`exploration` continues to investigate the exploration-exploitation tradeoff.
We will extend ideas from multi-armed bandits to the MDP setting.

{ref}`contextual_bandits` extends the multi-armed bandit setting with some observed state.

{ref}`background` contains an overview of selected background mathematical content and programming content.

<!-- 
| Chapter | States | Actions | Rewards (or costs) |
|:-------:|:------:|:-------:|:-------:|
| {ref}`bandits` | N/A | Finite | Stochastic |
| {ref}`mdps` | Finite | Finite | Deterministic |
| {ref}`fitted_dp` | Large or continuous | Finite | Deterministic |
| {ref}`lqr` | Continuous | Continuous | Deterministic |
-->

+++

## Notation

We will use the following notation throughout the book.
This notation is inspired by {cite}`sutton_reinforcement_2018` and {cite}`agarwal_reinforcement_2022`.
We use $[N]$ as shorthand for the set $\{ 0, 1, \dots, N-1 \}$.

| Element      | Space                    | Definition (of element)   |
|:------------:|:------------------------:|:--------------------------|
|      $s$     | $\mathcal{S}$            | A state.                  |
|      $a$     | $\mathcal{A}$            | An action.                |
|      $r$     |                          | A reward.                 |
|   $\gamma$   |                          | A discount factor.        |
|    $\tau$    | $\mathcal{T}$             | A trajectory.             |
|     $\pi$    | $\Pi$                    | A policy.                 |
|   $V^\pi$    | $\mathcal{S} \to \mathbb{R}$                         | The value function of policy $\pi$.                               |
|   $Q^\pi$    | $\mathcal{S} \times \mathcal{A} \to \mathbb{R}$                         | The action-value function (a.k.a. Q-function) of policy $\pi$. |
|   $A^\pi$    | $\mathcal{S} \times \mathcal{A} \to \mathbb{R}$                         | The advantage function of policy $\pi$.    |
|              | $\triangle(\mathcal{X})$ | A distribution supported on $\mathcal{X}$. |
<!-- |   $\mu$      | $\triangle(\mathcal{S})$ | A distribution over states.        | -->
|    $\hi$     |   $[\hor]$               | Time horizon index of an MDP.    |
|    $k$       |   $[K]$                  | Arm index of a multi-armed bandit. |
|    $t$       |   $[T]$                  | Iteration index of an algorithm.  |
|    $\theta$  | $\Theta$                 | A set of parameters. |

Note that throughout the text, certain symbols will stand for either random variables or fixed values.
We aim to clarify in ambiguous settings.

+++

(programming)=
## Programming

Why include code in a textbook?
We believe that implementing an algorithm is a strong test of your understanding of it;
mathematical notation can often abstract away details,
while a computer must be given every single instruction.
We have sought to write readable Python code that is self-contained within each file.
This approach is inspired by {cite}`sussman_functional_2013`.
There are some ways in which the code style differs from typical software projects:

- We keep use of language features to a minimum,
  even if it leads to code that could otherwise be more concisely or idiomatically expressed.
- The variable names used in the code match those used in the main text.
  For example, the variable `s` will be used instead of the more explicit `state`.

We also make extensive use of Python _type annotations_ to explicitly specify variable types, including shapes of vectors and matrices using the [jaxtyping](https://github.com/patrick-kidger/jaxtyping) library.

This is an interactive book built with [Jupyter Book](https://jupyterbook.org/en/stable/intro.html).
It uses [Python 3.11](https://docs.python.org/3.11/contents.html).
It uses the [JAX](https://jax.readthedocs.io/en/latest/index.html) library for numerical computing.
JAX was chosen for the clarity of its functional style and due to its mature RL ecosystem,
sustained in large part by the Google DeepMind research group and a large body of open-source contributors.
We use the standard [Gymnasium](https://gymnasium.farama.org/) library for interfacing with RL environments.
